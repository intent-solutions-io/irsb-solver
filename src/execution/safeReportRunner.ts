/**
 * SAFE_REPORT job runner.
 *
 * Produces deterministic report artifacts (JSON + Markdown).
 * No network calls, no external state - purely computational.
 */

import type { SafeReportInputs } from "../types/intent.js";
import type { RunContext } from "./runContext.js";
import type { JobRunner, RunResult, ArtifactInfo } from "./jobRunner.js";
import { successResult, failureResult } from "./jobRunner.js";
import { getSafeReportArtifactPaths } from "../artifacts/artifactPaths.js";
import { writeArtifacts } from "../artifacts/writeArtifacts.js";
import { canonicalJson } from "../utils/canonicalJson.js";

/**
 * Report version for schema tracking.
 */
export const REPORT_VERSION = "0.1.0";

/**
 * Maximum keys to show in summary.
 */
const MAX_SUMMARY_KEYS = 5;

/**
 * JSON report structure.
 */
export interface SafeReportJson {
  subject: string;
  data: Record<string, unknown>;
  summary: string;
  stats: {
    keysCount: number;
    approxBytes: number;
  };
  generatedBy: {
    jobType: string;
    intentId: string;
    runId: string;
    reportVersion: string;
  };
}

/**
 * Generates deterministic summary for the report.
 */
function generateSummary(data: Record<string, unknown>): string {
  const keys = Object.keys(data).sort();
  const count = keys.length;

  if (count === 0) {
    return "Empty data object - no keys to report.";
  }

  const displayKeys = keys.slice(0, MAX_SUMMARY_KEYS);
  const keyList = displayKeys.join(", ");

  if (count <= MAX_SUMMARY_KEYS) {
    return `Report contains ${String(count)} key(s): ${keyList}.`;
  }

  return `Report contains ${String(count)} key(s). First ${String(MAX_SUMMARY_KEYS)}: ${keyList}.`;
}

/**
 * Generates the JSON report content.
 */
function generateJsonReport(
  inputs: SafeReportInputs,
  ctx: RunContext
): SafeReportJson {
  const canonicalData = JSON.parse(canonicalJson(inputs.data)) as Record<
    string,
    unknown
  >;

  return {
    subject: inputs.subject,
    data: canonicalData,
    summary: generateSummary(canonicalData),
    stats: {
      keysCount: Object.keys(canonicalData).length,
      approxBytes: canonicalJson(inputs.data).length,
    },
    generatedBy: {
      jobType: ctx.jobType,
      intentId: ctx.intentId,
      runId: ctx.runId,
      reportVersion: REPORT_VERSION,
    },
  };
}

/**
 * Formats a value for markdown display.
 */
function formatValueForMarkdown(value: unknown): string {
  if (value === null) {
    return "`null`";
  }
  if (typeof value === "undefined") {
    return "`undefined`";
  }
  if (typeof value === "string") {
    return value;
  }
  if (typeof value === "number" || typeof value === "boolean") {
    return String(value);
  }
  // Objects and arrays: compact canonical JSON
  return `\`${canonicalJson(value)}\``;
}

/**
 * Generates the Markdown report content.
 */
function generateMarkdownReport(
  inputs: SafeReportInputs,
  ctx: RunContext
): string {
  const canonicalData = JSON.parse(canonicalJson(inputs.data)) as Record<
    string,
    unknown
  >;
  const summary = generateSummary(canonicalData);
  const sortedKeys = Object.keys(canonicalData).sort();

  const lines: string[] = [
    `# SAFE_REPORT: ${inputs.subject}`,
    "",
    "## Summary",
    "",
    summary,
    "",
    "## Data",
    "",
  ];

  if (sortedKeys.length === 0) {
    lines.push("_No data keys present._");
  } else {
    for (const key of sortedKeys) {
      const value = canonicalData[key];
      lines.push(`- **${key}**: ${formatValueForMarkdown(value)}`);
    }
  }

  lines.push("");
  lines.push("---");
  lines.push("");
  lines.push(`_Generated by ${ctx.jobType} | Intent: ${ctx.intentId} | Run: ${ctx.runId}_`);
  lines.push("");

  return lines.join("\n");
}

/**
 * SAFE_REPORT runner implementation.
 */
export const safeReportRunner: JobRunner = {
  jobType: "SAFE_REPORT",

  async run(inputs: SafeReportInputs, ctx: RunContext): Promise<RunResult> {
    // Use await to satisfy async requirement (future-proofs for async operations)
    await Promise.resolve();

    try {
      // Generate report content
      const jsonReport = generateJsonReport(inputs, ctx);
      const mdReport = generateMarkdownReport(inputs, ctx);

      // Get artifact paths
      const { jsonPath, mdPath } = getSafeReportArtifactPaths(ctx.artifactsDir);

      // Write artifacts atomically
      const artifacts: ArtifactInfo[] = writeArtifacts([
        { path: jsonPath, content: canonicalJson(jsonReport) + "\n" },
        { path: mdPath, content: mdReport },
      ]);

      return successResult(ctx, artifacts);
    } catch (error) {
      const message =
        error instanceof Error ? error.message : "Unknown error during execution";
      return failureResult(ctx, message);
    }
  },
};

/**
 * Export for testing.
 */
export { generateSummary, generateJsonReport, generateMarkdownReport };
